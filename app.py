import streamlit as st
import requests
import hashlib
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
from fpdf import FPDF
import random
import uuid
import json

# --- 1. PAGE CONFIGURATION ---
st.set_page_config(
    page_title="CyberSentinel Pro",
    page_icon="üõ°Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- 2. CUSTOM CSS ---
st.markdown("""
<style>
    /* BACKGROUND */
    .stApp {
        background: linear-gradient(135deg, #00C9FF 0%, #92FE9D 100%);
        background-attachment: fixed;
    }
    
    /* HEADER VISIBILITY FIX */
    header[data-testid="stHeader"] {
        background-color: rgba(255, 255, 255, 0.8) !important;
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(255,255,255,0.5);
    }
    header[data-testid="stHeader"] * { color: #000000 !important; }

    /* TEXT VISIBILITY */
    h1, h2, h3, h4, p, li, span, div, label {
        color: #0f172a !important;
        text-shadow: none !important;
    }
    
    /* BUTTON FIX */
    .stButton > button {
        background-color: #0f172a !important;
        color: #ffffff !important;
        border: 1px solid white !important;
        border-radius: 8px;
        font-weight: bold;
    }
    .stButton > button p { color: #ffffff !important; }
    .stButton > button:hover {
        background-color: #1e293b !important;
        transform: scale(1.02);
    }

    /* SIDEBAR */
    [data-testid="stSidebar"] {
        background-color: rgba(255, 255, 255, 0.9) !important;
        border-right: 1px solid rgba(255,255,255,0.5);
        backdrop-filter: blur(10px);
    }

    /* CARDS */
    div[data-testid="stMetric"], .stTabs [data-baseweb="tab-panel"] {
        background-color: rgba(255, 255, 255, 0.75);
        border-radius: 15px;
        padding: 20px;
        border: 1px solid #ffffff;
        box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        backdrop-filter: blur(10px);
    }
    
    /* INPUT BOXES */
    input[type="text"], input[type="password"], textarea {
        color: #000000 !important;
        background-color: #ffffff !important;
        border: 1px solid #ccc;
    }

    /* TABS */
    .stTabs [data-baseweb="tab"] {
        background-color: rgba(255,255,255,0.5);
        border-radius: 5px;
        color: #0f172a !important;
        font-weight: bold;
    }
    .stTabs [aria-selected="true"] {
        background-color: #ffffff;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
</style>
""", unsafe_allow_html=True)

# --- 3. CREATIVE PDF GENERATOR ---
class CreativePDF(FPDF):
    def header(self):
        self.set_fill_color(15, 23, 42)
        self.rect(0, 0, 210, 40, 'F')
        self.set_font('Arial', 'B', 24)
        self.set_text_color(255, 255, 255)
        self.cell(0, 20, 'CyberSentinel', 0, 1, 'C')
        self.set_font('Arial', '', 12)
        self.cell(0, 5, 'OFFICIAL SECURITY AUDIT REPORT', 0, 1, 'C')
        self.ln(20)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.set_text_color(128, 128, 128)
        self.cell(0, 10, f'Page {self.page_no()} | Generated by CyberSentinel System', 0, 0, 'C')

def generate_creative_pdf(email, score, breaches, phishing_result=None):
    pdf = CreativePDF()
    pdf.add_page()
    
    # Target Info
    pdf.set_text_color(0, 0, 0)
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(0, 10, f"AUDIT TARGET: {email}", 0, 1, 'L')
    pdf.cell(0, 10, f"DATE: {datetime.now().strftime('%Y-%m-%d')}", 0, 1, 'L')
    pdf.line(10, 65, 200, 65)
    
    # Risk Score
    pdf.ln(10)
    pdf.set_fill_color(240, 240, 250)
    pdf.rect(10, 75, 190, 40, 'F') 
    pdf.set_y(80)
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(0, 10, "IDENTITY RISK SCORE", 0, 1, 'C')
    pdf.set_font("Arial", 'B', 30)
    if score > 50:
        pdf.set_text_color(220, 20, 60)
        status = "CRITICAL RISK"
    else:
        pdf.set_text_color(0, 128, 0)
        status = "SECURE"
    pdf.cell(0, 15, f"{score}/100 ({status})", 0, 1, 'C')
    pdf.set_text_color(0, 0, 0)

    # Phishing Report (If available)
    if phishing_result:
        pdf.ln(20)
        pdf.set_font("Arial", 'B', 14)
        pdf.set_fill_color(15, 23, 42)
        pdf.set_text_color(255, 255, 255)
        pdf.cell(0, 10, " PHISHING SCAN RESULT", 1, 1, 'L', fill=True)
        pdf.set_text_color(0, 0, 0)
        pdf.set_font("Arial", '', 10)
        pdf.ln(2)
        
        # Determine Safe/Unsafe
        # Arya AI returns model_score: near 1 is unsafe, near 0 is safe
        try:
            p_score = float(phishing_result.get('data', {}).get('model_score', 0))
            is_phish = "DETECTED" if p_score > 0.5 else "SAFE"
            pdf.cell(0, 10, f"Status: {is_phish} (Confidence: {p_score:.2f})", 0, 1)
        except:
            pdf.cell(0, 10, "Status: Analysis Error", 0, 1)

    # Breach Table
    pdf.ln(10)
    pdf.set_font("Arial", 'B', 14)
    pdf.set_fill_color(15, 23, 42)
    pdf.set_text_color(255, 255, 255)
    pdf.cell(0, 10, " FORENSIC EVIDENCE LOG", 1, 1, 'L', fill=True)
    pdf.set_text_color(0, 0, 0)
    pdf.set_font("Arial", '', 10)
    
    fill = False
    if breaches:
        for b in breaches:
            if fill: pdf.set_fill_color(230, 240, 255)
            else: pdf.set_fill_color(255, 255, 255)
            
            name = str(b['Name'])
            date = str(b.get('BreachDate', 'N/A'))
            desc = str(b.get('Description', 'No details'))[:70] + "..."
            
            pdf.cell(40, 10, f" {name}", 1, 0, 'L', fill=fill)
            pdf.cell(30, 10, f" {date}", 1, 0, 'L', fill=fill)
            pdf.cell(0, 10, f" {desc}", 1, 1, 'L', fill=fill)
            fill = not fill
    else:
        pdf.cell(0, 10, " No breaches found.", 1, 1, 'L')

    pdf.output("Risk_Report.pdf")

# --- 4. BACKEND LOGIC ---
def estimate_date(site_name):
    site_lower = str(site_name).lower()
    known_dates = {
        "linkedin": "2016-05-17", "adobe": "2013-10-04", "canva": "2019-05-24",
        "facebook": "2019-08-30", "twitter": "2022-07-21", "myspace": "2008-07-17",
        "dropbox": "2012-07-01", "zomato": "2017-05-18", "uber": "2016-10-01"
    }
    for key, date in known_dates.items():
        if key in site_lower: return date
    start_date = datetime(2018, 1, 1)
    end_date = datetime(2024, 1, 1)
    random_days = random.randrange((end_date - start_date).days)
    return (start_date + timedelta(days=random_days)).strftime("%Y-%m-%d")

def get_mock_breaches():
    return [
        {"Name": "LinkedIn", "BreachDate": "2016-05-17", "DataClasses": ["Email", "Passwords"], "Description": "164M accounts exposed."},
        {"Name": "Adobe", "BreachDate": "2013-10-04", "DataClasses": ["Email", "Hints"], "Description": "Creative Cloud hack."},
        {"Name": "Zomato", "BreachDate": "2017-05-18", "DataClasses": ["Email", "Passwords"], "Description": "Food delivery breach."},
        {"Name": "Canva", "BreachDate": "2019-05-24", "DataClasses": ["Email", "Names"], "Description": "Design tool hack."}
    ]

def get_real_breaches(email):
    url = f"https://leakcheck.io/api/public?check={email}"
    try:
        response = requests.get(url, timeout=5)
        data = response.json()
        if data.get('success') and data.get('sources'):
            real_breaches = []
            for source in data.get('sources'):
                name = source.get('name') if isinstance(source, dict) else source
                estimated_date = estimate_date(name)
                real_breaches.append({
                    "Name": name, 
                    "BreachDate": estimated_date, 
                    "DataClasses": ["Email", "Password"], 
                    "Description": "Public Database Leak"
                })
            return real_breaches
        return []
    except:
        return None

# --- NEW ARYA.AI PHISHING FUNCTION ---
def check_phishing_arya(input_text, input_type="url"):
    api_url = "https://ping.arya.ai/api/v1/phishing-detection"
    token = "9d75aec4f0656c97a87fe4be48d5fa4d" # YOUR TOKEN
    
    headers = {
        'token': token,
        'content-type': 'application/json'
    }
    
    payload = {
        "input_data": input_text,
        "input_type": input_type,
        "req_id": str(uuid.uuid4())
    }
    
    try:
        response = requests.post(api_url, json=payload, headers=headers, timeout=10)
        return response.json()
    except Exception as e:
        return {"success": False, "error_message": str(e)}

def check_password_pwned(password):
    sha1pass = hashlib.sha1(password.encode('utf-8')).hexdigest().upper()
    prefix, suffix = sha1pass[:5], sha1pass[5:]
    try:
        res = requests.get(f"https://api.pwnedpasswords.com/range/{prefix}", timeout=5)
        if res.status_code == 200:
            for line in res.text.splitlines():
                h, count = line.split(':')
                if h == suffix: return int(count)
    except: return -1
    return 0

def calculate_risk(breaches):
    score = 0
    weights = {'Passwords': 30, 'Email': 10, 'Phone': 50, 'Credit Card': 80}
    current_year = datetime.now().year
    
    for b in breaches:
        breach_date_str = b.get('BreachDate', '2020-01-01')
        try: breach_year = int(breach_date_str.split('-')[0])
        except: breach_year = 2020
        age = max(1, current_year - breach_year)
        decay_factor = 1.0 / (age ** 0.5)
        
        breach_score = 0
        for dtype in b.get('DataClasses', []):
            breach_score += weights.get(dtype, 15)
        score += (breach_score * decay_factor)
        
    return min(int(score), 100)

# --- 5. THE UI LAYOUT ---
st.markdown("<h1>üõ°Ô∏è CyberSentinel <br><span style='font-size: 20px;'>Advanced Identity Leak Auditor</span></h1>", unsafe_allow_html=True)
st.divider()

# Session state initialization
if 'phishing_result' not in st.session_state:
    st.session_state['phishing_result'] = None

with st.sidebar:
    st.markdown("### ‚öôÔ∏è Control Panel")
    email_input = st.text_input("Target Email Address", "demo@test.com")
    pass_input = st.text_input("Password Check (Optional)", type="password")
    st.markdown("<br>", unsafe_allow_html=True)
    if st.button("üöÄ INITIATE SCAN"):
        st.session_state['run'] = True
    st.markdown("---")
    st.caption("üîí Zero-Knowledge Architecture.")

if st.session_state.get('run'):
    with st.spinner("üïµÔ∏è Scouring Dark Web Databases..."):
        breaches = get_real_breaches(email_input)
        is_sim = False
        if not breaches and email_input == "demo@test.com":
            breaches = get_mock_breaches()
            is_sim = True
        risk_score = calculate_risk(breaches) if breaches else 0

    if risk_score > 50:
        st.error(f"üö® CRITICAL THREAT DETECTED: Risk Score {risk_score}/100")
    elif risk_score > 0:
        st.warning(f"‚ö†Ô∏è MODERATE RISK: Risk Score {risk_score}/100")
    else:
        st.success("‚úÖ SYSTEM SECURE: No data breaches found.")

    if is_sim: st.caption("‚ÑπÔ∏è Running in Simulation Mode for Demonstration")

    # TABS: Added "Phishing Scanner"
    tab1, tab2, tab3, tab4 = st.tabs(["üìä Live Dashboard", "üï∏Ô∏è Attack Map", "üîë Password Lab", "üé£ Phishing Scanner"])

    with tab1:
        col1, col2, col3 = st.columns(3)
        col1.metric("Total Breaches", len(breaches) if breaches else 0)
        col2.metric("Identity Risk Score", f"{risk_score}/100", delta="High Risk" if risk_score > 50 else "Safe")
        col3.metric("Data Source", "Simulation" if is_sim else "Live API")

        st.markdown("### üìú Forensic Log")
        if breaches:
            for b in breaches:
                with st.expander(f"üî¥ {b['Name']} ({b.get('BreachDate', 'N/A')})"):
                    st.write(f"**Description:** {b.get('Description', 'No details available.')}")
                    st.write(f"**Compromised Data:** {', '.join(b.get('DataClasses', []))}")
        else: st.info("No breaches to display.")

    with tab2:
        st.markdown("### üìÖ Timeline of Compromise")
        if breaches:
            dates = [datetime.strptime(b.get('BreachDate', '2021-01-01'), "%Y-%m-%d") for b in breaches]
            names = [b['Name'] for b in breaches]
            
            fig, ax = plt.subplots(figsize=(12, 5))
            fig.patch.set_alpha(0)
            ax.patch.set_alpha(0)
            
            levels = [random.uniform(0.8, 2.5) for _ in range(len(dates))]
            markerline, stemline, baseline = ax.stem(dates, levels)
            
            plt.setp(stemline, color='#0f172a', linewidth=2, linestyle=':')
            plt.setp(markerline, marker='D', markersize=12, markerfacecolor='#ff0055', markeredgecolor='white', markeredgewidth=2)
            plt.setp(baseline, visible=False)
            
            ax.get_yaxis().set_visible(False)
            ax.spines['top'].set_visible(False)
            ax.spines['right'].set_visible(False)
            ax.spines['left'].set_visible(False)
            ax.spines['bottom'].set_color('#0f172a')
            
            ax.xaxis.set_major_locator(mdates.YearLocator())
            ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y"))
            ax.tick_params(axis='x', colors='#0f172a')
            
            for d, l, name in zip(dates, levels, names):
                ax.annotate(name, xy=(d, l), xytext=(0, 10), textcoords="offset points", ha='center', fontweight='bold', color="#ffffff", bbox=dict(boxstyle="round,pad=0.3", fc="#0f172a", alpha=0.8))
            st.pyplot(fig)
        else: st.info("No timeline data available.")

    with tab3:
        st.markdown("### üîê Password Strength Analysis")
        if pass_input:
            leaks = check_password_pwned(pass_input)
            if leaks > 0: st.error(f"Password exposed {leaks:,} times. CHANGE IMMEDIATELY.")
            elif leaks == 0: st.success("Password NOT found in known leaks.")
            else: st.warning("Connection failed.")
        else: st.info("Enter password in sidebar to test.")
        
    with tab4:
        st.markdown("### üé£ AI Phishing Detector (Powered by Arya.ai)")
        st.markdown("Paste a suspicious URL or Email content below to check if it's phishing.")
        
        phish_input = st.text_area("Suspicious Content (URL or Text)", height=100)
        input_type = st.radio("Input Type", ["url", "email_text"], horizontal=True)
        
        if st.button("üîç Scan for Phishing"):
            if phish_input:
                with st.spinner("ü§ñ AI Model Analyzing..."):
                    result = check_phishing_arya(phish_input, input_type)
                    st.session_state['phishing_result'] = result
                    
                    if result.get('success'):
                        data = result.get('data', {})
                        model_score = float(data.get('model_score', 0))
                        # Assuming score > 0.5 is malicious (standard ML threshold)
                        
                        colA, colB = st.columns([1, 2])
                        with colA:
                            if model_score > 0.5:
                                st.markdown("# üö® PHISHING")
                            else:
                                st.markdown("# ‚úÖ SAFE")
                        with colB:
                            st.progress(model_score)
                            st.write(f"**AI Confidence Score:** {model_score:.4f}")
                            if model_score > 0.5:
                                st.error("This content has been flagged as MALICIOUS.")
                            else:
                                st.success("This content appears to be LEGITIMATE.")
                    else:
                        st.error(f"API Error: {result.get('error_message')}")
            else:
                st.warning("Please enter text or URL to scan.")

    st.divider()
    if st.button("üìÑ Export Forensic PDF Report"):
        # Pass the phishing result to the PDF generator
        generate_creative_pdf(email_input, risk_score, breaches if breaches else [], st.session_state.get('phishing_result'))
        with open("Risk_Report.pdf", "rb") as f:
            st.download_button("üì• Download PDF", f, "Risk_Report.pdf")
else:
    st.info("üëà Enter an email in the sidebar and click 'INITIATE SCAN' to begin.")
