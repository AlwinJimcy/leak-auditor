import streamlit as st
import requests
import hashlib
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
from fpdf import FPDF
import random
import time
import json

# ==========================================
# 1. CONFIGURATION & SETUP
# ==========================================
st.set_page_config(
    page_title="CyberSentinel Pro",
    page_icon="üõ°Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- API KEYS (REPLACE THESE) ---
GOOGLE_API_KEY = "AIzaSyDd6eC6KYprKwAAh-MtambAu7vw8GJfoIo"
VIRUSTOTAL_API_KEY = "b323485c8e352c86d49c2a044182ad2a6fcae2a5495b88f12a7e8aea99733616"

# --- CUSTOM CSS ---
st.markdown("""
<style>
    /* BACKGROUND */
    .stApp {
        background: linear-gradient(135deg, #00C9FF 0%, #92FE9D 100%);
        background-attachment: fixed;
    }
    
    /* HEADER VISIBILITY FIX */
    header[data-testid="stHeader"] {
        background-color: rgba(255, 255, 255, 0.8) !important;
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(255,255,255,0.5);
    }
    header[data-testid="stHeader"] * { color: #000000 !important; }

    /* TEXT VISIBILITY */
    h1, h2, h3, h4, p, li, span, div, label {
        color: #0f172a !important;
        text-shadow: none !important;
    }
    
    /* BUTTON FIX */
    .stButton > button {
        background-color: #0f172a !important;
        color: #ffffff !important;
        border: 1px solid white !important;
        border-radius: 8px;
        font-weight: bold;
    }
    .stButton > button p { color: #ffffff !important; }
    .stButton > button:hover {
        background-color: #1e293b !important;
        transform: scale(1.02);
    }

    /* SIDEBAR */
    [data-testid="stSidebar"] {
        background-color: rgba(255, 255, 255, 0.9) !important;
        border-right: 1px solid rgba(255,255,255,0.5);
        backdrop-filter: blur(10px);
    }

    /* CARDS */
    div[data-testid="stMetric"], .stTabs [data-baseweb="tab-panel"], .stAlert {
        background-color: rgba(255, 255, 255, 0.75);
        border-radius: 15px;
        padding: 20px;
        border: 1px solid #ffffff;
        box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        backdrop-filter: blur(10px);
    }
    
    /* INPUT BOXES */
    input[type="text"], input[type="password"] {
        color: #000000 !important;
        background-color: #ffffff !important;
        border: 1px solid #ccc;
    }

    /* TABS */
    .stTabs [data-baseweb="tab"] {
        background-color: rgba(255,255,255,0.5);
        border-radius: 5px;
        color: #0f172a !important;
        font-weight: bold;
    }
    .stTabs [aria-selected="true"] {
        background-color: #ffffff;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
</style>
""", unsafe_allow_html=True)

# ==========================================
# 2. SHARED HELPER FUNCTIONS
# ==========================================

class CreativePDF(FPDF):
    def header(self):
        self.set_fill_color(15, 23, 42)
        self.rect(0, 0, 210, 40, 'F')
        self.set_font('Arial', 'B', 24)
        self.set_text_color(255, 255, 255)
        self.cell(0, 20, 'CyberSentinel', 0, 1, 'C')
        self.set_font('Arial', '', 12)
        self.cell(0, 5, 'OFFICIAL SECURITY AUDIT REPORT', 0, 1, 'C')
        self.ln(20)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.set_text_color(128, 128, 128)
        self.cell(0, 10, f'Page {self.page_no()} | Generated by CyberSentinel System', 0, 0, 'C')

def generate_creative_pdf(email, score, breaches):
    pdf = CreativePDF()
    pdf.add_page()
    
    pdf.set_text_color(0, 0, 0)
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(0, 10, f"AUDIT TARGET: {email}", 0, 1, 'L')
    pdf.cell(0, 10, f"DATE: {datetime.now().strftime('%Y-%m-%d')}", 0, 1, 'L')
    pdf.line(10, 65, 200, 65)
    
    pdf.ln(10)
    pdf.set_fill_color(240, 240, 250)
    pdf.rect(10, 75, 190, 40, 'F') 
    pdf.set_y(80)
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(0, 10, "IDENTITY RISK SCORE", 0, 1, 'C')
    pdf.set_font("Arial", 'B', 30)
    if score > 50:
        pdf.set_text_color(220, 20, 60)
        status = "CRITICAL RISK"
    else:
        pdf.set_text_color(0, 128, 0)
        status = "SECURE"
    pdf.cell(0, 15, f"{score}/100 ({status})", 0, 1, 'C')
    pdf.set_text_color(0, 0, 0)

    pdf.ln(20)
    pdf.set_font("Arial", 'B', 14)
    pdf.set_fill_color(15, 23, 42)
    pdf.set_text_color(255, 255, 255)
    pdf.cell(0, 10, " FORENSIC EVIDENCE LOG", 1, 1, 'L', fill=True)
    pdf.set_text_color(0, 0, 0)
    pdf.set_font("Arial", '', 10)
    
    fill = False
    if breaches:
        for b in breaches:
            if fill: pdf.set_fill_color(230, 240, 255)
            else: pdf.set_fill_color(255, 255, 255)
            
            name = str(b['Name'])
            date = str(b.get('BreachDate', 'N/A'))
            desc = str(b.get('Description', 'No details'))[:70] + "..."
            
            pdf.cell(40, 10, f" {name}", 1, 0, 'L', fill=fill)
            pdf.cell(30, 10, f" {date}", 1, 0, 'L', fill=fill)
            pdf.cell(0, 10, f" {desc}", 1, 1, 'L', fill=fill)
            fill = not fill
    else:
        pdf.cell(0, 10, " No breaches found.", 1, 1, 'L')

    pdf.output("Risk_Report.pdf")

# ==========================================
# 3. MODULE 1: IDENTITY AUDITOR
# ==========================================

def estimate_date(site_name):
    site_lower = str(site_name).lower()
    known_dates = {
        "linkedin": "2016-05-17", "adobe": "2013-10-04", "canva": "2019-05-24",
        "facebook": "2019-08-30", "twitter": "2022-07-21", "myspace": "2008-07-17",
        "dropbox": "2012-07-01", "zomato": "2017-05-18", "uber": "2016-10-01"
    }
    for key, date in known_dates.items():
        if key in site_lower: return date
    start_date = datetime(2018, 1, 1)
    end_date = datetime(2024, 1, 1)
    random_days = random.randrange((end_date - start_date).days)
    return (start_date + timedelta(days=random_days)).strftime("%Y-%m-%d")

def get_mock_breaches():
    return [
        {"Name": "LinkedIn", "BreachDate": "2016-05-17", "DataClasses": ["Email", "Passwords", "Job titles"], "Description": "164 Million accounts exposed."},
        {"Name": "Adobe", "BreachDate": "2013-10-04", "DataClasses": ["Email", "Hints"], "Description": "153 Million accounts exposed."},
        {"Name": "Zomato", "BreachDate": "2017-05-18", "DataClasses": ["Email", "Passwords"], "Description": "17 Million user records leaked."}
    ]

def get_real_breaches(email):
    url = f"https://leakcheck.io/api/public?check={email}"
    try:
        response = requests.get(url, timeout=5)
        data = response.json()
        if data.get('success') and data.get('sources'):
            real_breaches = []
            for source in data.get('sources'):
                name = source.get('name') if isinstance(source, dict) else source
                real_breaches.append({
                    "Name": name, "BreachDate": estimate_date(name),
                    "DataClasses": ["Email", "Password"], "Description": "Public Database Leak"
                })
            return real_breaches
        return []
    except: return None

def check_password_pwned(password):
    sha1pass = hashlib.sha1(password.encode('utf-8')).hexdigest().upper()
    prefix, suffix = sha1pass[:5], sha1pass[5:]
    try:
        res = requests.get(f"https://api.pwnedpasswords.com/range/{prefix}", timeout=5)
        if res.status_code == 200:
            for line in res.text.splitlines():
                h, count = line.split(':')
                if h == suffix: return int(count)
    except: return -1
    return 0

def calculate_risk(breaches):
    score = 0
    current_year = datetime.now().year
    weights = {'Passwords': 30, 'Email': 10, 'Phone': 50, 'Credit Card': 80}
    
    for b in breaches:
        breach_date_str = b.get('BreachDate', '2020-01-01')
        try: breach_year = int(breach_date_str.split('-')[0])
        except: breach_year = 2020
        age = max(1, current_year - breach_year)
        decay_factor = 1.0 / (age ** 0.5)
        
        breach_score = sum([weights.get(dtype, 15) for dtype in b.get('DataClasses', [])])
        score += (breach_score * decay_factor)
        
    return min(int(score), 100)

# ==========================================
# 4. MODULE 2: HYBRID URL SCANNER
# ==========================================

def check_google_safe_browsing(url):
    endpoint = f"https://safebrowsing.googleapis.com/v4/threatMatches:find?key={GOOGLE_API_KEY}"
    payload = {
        "client": {"clientId": "cyber-sentinel", "clientVersion": "1.0.0"},
        "threatInfo": {
            "threatTypes": ["MALWARE", "SOCIAL_ENGINEERING", "UNWANTED_SOFTWARE"],
            "platformTypes": ["ANY_PLATFORM"],
            "threatEntryTypes": ["URL"],
            "threatEntries": [{"url": url}]
        }
    }
    try:
        response = requests.post(endpoint, json=payload)
        data = response.json()
        if "matches" in data:
            return {"status": "malicious", "source": "Google Safe Browsing", "detail": data["matches"][0]["threatType"]}
        return {"status": "clean"}
    except Exception as e:
        return {"status": "error", "message": str(e)}

def check_virustotal(url):
    headers = {"x-apikey": VIRUSTOTAL_API_KEY, "content-type": "application/x-www-form-urlencoded"}
    try:
        # Step 1: Submit URL
        scan_url = "https://www.virustotal.com/api/v3/urls"
        data = {"url": url}
        resp = requests.post(scan_url, headers=headers, data=data)
        
        if resp.status_code != 200:
            return {"status": "error", "message": f"VT API Error: {resp.status_code}"}
            
        analysis_id = resp.json()["data"]["id"]
        
        # Step 2: Poll Results
        analysis_url = f"https://www.virustotal.com/api/v3/analyses/{analysis_id}"
        with st.spinner("Deep scanning with VirusTotal (approx 15s)..."):
            for _ in range(6): # Poll for ~30 seconds
                time.sleep(5)
                report_resp = requests.get(analysis_url, headers=headers)
                report = report_resp.json()
                status = report["data"]["attributes"]["status"]
                
                if status == "completed":
                    stats = report["data"]["attributes"]["stats"]
                    malicious = stats["malicious"]
                    if malicious > 0:
                        return {"status": "malicious", "source": "VirusTotal", "malicious_votes": malicious, "total_votes": sum(stats.values())}
                    else:
                        return {"status": "clean", "source": "VirusTotal"}
        return {"status": "timeout", "message": "Analysis timed out."}
    except Exception as e:
        return {"status": "error", "message": str(e)}

# ==========================================
# 5. MAIN APPLICATION
# ==========================================

st.sidebar.title("üõ°Ô∏è CyberSentinel")
app_mode = st.sidebar.radio("Select Module:", ["Identity Auditor", "PhishGuard URL Scanner"])

st.sidebar.markdown("---")
st.sidebar.caption("üîí Zero-Knowledge Architecture")

# --- APP MODE: IDENTITY AUDITOR ---
if app_mode == "Identity Auditor":
    st.markdown("<h1>üë§ Identity Leak Auditor<br><span style='font-size: 20px;'>Dark Web Credential Monitor</span></h1>", unsafe_allow_html=True)
    st.divider()

    col_a, col_b = st.columns([1, 2])
    with col_a:
        email_input = st.text_input("Target Email Address", "demo@test.com")
        pass_input = st.text_input("Password Check (Optional)", type="password")
        scan_clicked = st.button("üöÄ INITIATE SCAN")

    if scan_clicked:
        st.session_state['run_audit'] = True
    
    if st.session_state.get('run_audit'):
        with st.spinner("üïµÔ∏è Scouring Dark Web Databases..."):
            breaches = get_real_breaches(email_input)
            is_sim = False
            if not breaches and email_input == "demo@test.com":
                breaches = get_mock_breaches()
                is_sim = True
            risk_score = calculate_risk(breaches) if breaches else 0

        # Risk Banner
        if risk_score > 50:
            st.error(f"üö® CRITICAL THREAT DETECTED: Risk Score {risk_score}/100")
        elif risk_score > 0:
            st.warning(f"‚ö†Ô∏è MODERATE RISK: Risk Score {risk_score}/100")
        else:
            st.success("‚úÖ SYSTEM SECURE: No data breaches found.")

        if is_sim: st.caption("‚ÑπÔ∏è Running in Simulation Mode for Demonstration")

        # Tabs
        tab1, tab2, tab3 = st.tabs(["üìä Live Dashboard", "üï∏Ô∏è Attack Map", "üîë Password Lab"])

        with tab1:
            c1, c2, c3 = st.columns(3)
            c1.metric("Total Breaches", len(breaches) if breaches else 0)
            c2.metric("Identity Risk Score", f"{risk_score}/100")
            c3.metric("Data Source", "Simulation" if is_sim else "Live API")

            if breaches:
                for b in breaches:
                    with st.expander(f"üî¥ {b['Name']} ({b.get('BreachDate', 'N/A')})"):
                        st.write(f"**Description:** {b.get('Description', 'No details available.')}")
                        st.write(f"**Compromised:** {', '.join(b.get('DataClasses', []))}")
            else: st.info("No breaches to display.")

        with tab2:
            if breaches:
                dates = [datetime.strptime(b.get('BreachDate', '2021-01-01'), "%Y-%m-%d") for b in breaches]
                names = [b['Name'] for b in breaches]
                fig, ax = plt.subplots(figsize=(10, 4))
                fig.patch.set_alpha(0)
                ax.patch.set_alpha(0)
                
                markerline, stemline, baseline = ax.stem(dates, [1]*len(dates))
                plt.setp(markerline, marker='D', markersize=8, markeredgecolor="#0f172a", markerfacecolor="white")
                plt.setp(stemline, color='#0f172a', linestyle='--')
                ax.get_yaxis().set_visible(False)
                ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['left'].set_visible(False)
                ax.spines['bottom'].set_color('#0f172a')
                ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y"))
                ax.tick_params(axis='x', colors='#000')
                for d, name in zip(dates, names):
                    ax.annotate(name, xy=(d, 1.1), xytext=(0, 5), textcoords="offset points", ha='center', fontweight='bold', color="#0f172a")
                st.pyplot(fig)
            else: st.info("No timeline data.")

        with tab3:
            if pass_input:
                leaks = check_password_pwned(pass_input)
                if leaks > 0: st.error(f"Password exposed {leaks:,} times. CHANGE IMMEDIATELY.")
                elif leaks == 0: st.success("Password NOT found in known leaks.")
                else: st.warning("Connection failed.")
            else: st.info("Enter password in top section to test.")

        st.divider()
        if st.button("üìÑ Export Forensic PDF Report"):
            generate_creative_pdf(email_input, risk_score, breaches if breaches else [])
            with open("Risk_Report.pdf", "rb") as f:
                st.download_button("üì• Download PDF", f, "Risk_Report.pdf")

# --- APP MODE: URL SCANNER ---
elif app_mode == "PhishGuard URL Scanner":
    st.markdown("<h1>üåê PhishGuard<br><span style='font-size: 20px;'>Hybrid URL Threat Analyzer</span></h1>", unsafe_allow_html=True)
    st.divider()

    st.markdown("""
    This scanner uses a **Hybrid Defense Layer**:
    1.  **Fast Layer:** Checks Google Safe Browsing instantly.
    2.  **Deep Layer:** If 'clean', performs deep analysis via VirusTotal (70+ engines).
    """)
    
    url_input = st.text_input("Enter Suspicious URL:", placeholder="http://example.com/login")
    if st.button("üîç ANALYZE LINK"):
        if url_input:
            st.write("---")
            
            # Layer 1
            st.subheader("1. Fast Layer (Google Safe Browsing)")
            fast_result = check_google_safe_browsing(url_input)
            
            if fast_result["status"] == "malicious":
                st.error(f"üö® BLOCKED! Detected by {fast_result['source']}")
                st.write(f"**Threat Type:** {fast_result['detail']}")
            elif fast_result["status"] == "error":
                st.warning(f"‚ö†Ô∏è Google API Error: {fast_result.get('message')}")
            else:
                st.success("‚úÖ Google Safe Browsing: Clean")
                
                # Layer 2 (Only if Layer 1 is clean)
                st.subheader("2. Deep Layer (VirusTotal)")
                deep_result = check_virustotal(url_input)
                
                if deep_result["status"] == "malicious":
                    st.error(f"üö® BLOCKED! Detected by {deep_result['source']}")
                    st.metric("Malicious Votes", f"{deep_result['malicious_votes']}/{deep_result['total_votes']}")
                elif deep_result["status"] == "clean":
                    st.success("‚úÖ VirusTotal: Clean (0 detections)")
                    st.balloons()
                    st.info("This URL is likely safe.")
                else:
                    st.error(f"Error in deep scan: {deep_result.get('message')}")
        else:
            st.warning("Please enter a URL.")
