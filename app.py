import streamlit as st
import requests
import hashlib
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
from fpdf import FPDF
import random
import time
import json
import re
from urllib.parse import urlparse

# ==========================================
# 1. CONFIGURATION & SETUP
# ==========================================
st.set_page_config(
    page_title="CyberSentinel Pro",
    page_icon="üõ°Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- API KEYS (REPLACE THESE WITH YOUR ACTUAL KEYS) ---
GOOGLE_API_KEY = "YOUR_GOOGLE_SAFE_BROWSING_KEY"
VIRUSTOTAL_API_KEY = "YOUR_VIRUSTOTAL_API_KEY"

# --- CUSTOM CSS ---
st.markdown("""
<style>
    /* BACKGROUND */
    .stApp {
        background: linear-gradient(135deg, #00C9FF 0%, #92FE9D 100%);
        background-attachment: fixed;
    }
    
    /* HEADER VISIBILITY FIX */
    header[data-testid="stHeader"] {
        background-color: rgba(255, 255, 255, 0.8) !important;
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(255,255,255,0.5);
    }
    header[data-testid="stHeader"] * { color: #000000 !important; }

    /* TEXT VISIBILITY */
    h1, h2, h3, h4, p, li, span, div, label {
        color: #0f172a !important;
        text-shadow: none !important;
    }
    
    /* BUTTON FIX */
    .stButton > button {
        background-color: #0f172a !important;
        color: #ffffff !important;
        border: 1px solid white !important;
        border-radius: 8px;
        font-weight: bold;
    }
    .stButton > button p { color: #ffffff !important; }
    .stButton > button:hover {
        background-color: #1e293b !important;
        transform: scale(1.02);
    }

    /* SIDEBAR */
    [data-testid="stSidebar"] {
        background-color: rgba(255, 255, 255, 0.9) !important;
        border-right: 1px solid rgba(255,255,255,0.5);
        backdrop-filter: blur(10px);
    }

    /* CARDS */
    div[data-testid="stMetric"], .stTabs [data-baseweb="tab-panel"], .stAlert {
        background-color: rgba(255, 255, 255, 0.75);
        border-radius: 15px;
        padding: 20px;
        border: 1px solid #ffffff;
        box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        backdrop-filter: blur(10px);
    }
    
    /* INPUT BOXES */
    input[type="text"], input[type="password"] {
        color: #000000 !important;
        background-color: #ffffff !important;
        border: 1px solid #ccc;
    }

    /* TABS */
    .stTabs [data-baseweb="tab"] {
        background-color: rgba(255,255,255,0.5);
        border-radius: 5px;
        color: #0f172a !important;
        font-weight: bold;
    }
    .stTabs [aria-selected="true"] {
        background-color: #ffffff;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
</style>
""", unsafe_allow_html=True)

# ==========================================
# 2. SHARED HELPER FUNCTIONS
# ==========================================

class CreativePDF(FPDF):
    def header(self):
        self.set_fill_color(15, 23, 42)
        self.rect(0, 0, 210, 40, 'F')
        self.set_font('Arial', 'B', 24)
        self.set_text_color(255, 255, 255)
        self.cell(0, 20, 'CyberSentinel', 0, 1, 'C')
        self.set_font('Arial', '', 12)
        self.cell(0, 5, 'OFFICIAL SECURITY AUDIT REPORT', 0, 1, 'C')
        self.ln(20)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.set_text_color(128, 128, 128)
        self.cell(0, 10, f'Page {self.page_no()} | Generated by CyberSentinel System', 0, 0, 'C')

def generate_creative_pdf(email, score, breaches, priority):
    pdf = CreativePDF()
    pdf.add_page()
    
    pdf.set_text_color(0, 0, 0)
    pdf.set_font("Arial", 'B', 12)
    pdf.cell(0, 10, f"AUDIT TARGET: {email}", 0, 1, 'L')
    pdf.cell(0, 10, f"DATE: {datetime.now().strftime('%Y-%m-%d')}", 0, 1, 'L')
    pdf.line(10, 65, 200, 65)
    
    pdf.ln(10)
    pdf.set_fill_color(240, 240, 250)
    pdf.rect(10, 75, 190, 40, 'F') 
    pdf.set_y(80)
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(0, 10, "IDENTITY RISK ASSESSMENT", 0, 1, 'C')
    pdf.set_font("Arial", 'B', 30)
    
    if priority == "CRITICAL" or priority == "HIGH":
        pdf.set_text_color(220, 20, 60) # Red
    elif priority == "MEDIUM":
        pdf.set_text_color(255, 165, 0) # Orange
    else:
        pdf.set_text_color(0, 128, 0) # Green
        
    pdf.cell(0, 15, f"{priority} RISK ({score}/100)", 0, 1, 'C')
    pdf.set_text_color(0, 0, 0)

    pdf.ln(20)
    pdf.set_font("Arial", 'B', 14)
    pdf.set_fill_color(15, 23, 42)
    pdf.set_text_color(255, 255, 255)
    pdf.cell(0, 10, " FORENSIC EVIDENCE LOG", 1, 1, 'L', fill=True)
    pdf.set_text_color(0, 0, 0)
    pdf.set_font("Arial", '', 10)
    
    fill = False
    if breaches:
        for b in breaches:
            if fill: pdf.set_fill_color(230, 240, 255)
            else: pdf.set_fill_color(255, 255, 255)
            
            name = str(b['Name'])
            date = str(b.get('BreachDate', 'N/A'))
            desc = str(b.get('Description', 'No details'))[:70] + "..."
            
            pdf.cell(40, 10, f" {name}", 1, 0, 'L', fill=fill)
            pdf.cell(30, 10, f" {date}", 1, 0, 'L', fill=fill)
            pdf.cell(0, 10, f" {desc}", 1, 1, 'L', fill=fill)
            fill = not fill
    else:
        pdf.cell(0, 10, " No breaches found.", 1, 1, 'L')

    pdf.output("Risk_Report.pdf")

# ==========================================
# 3. MODULE 1: IDENTITY AUDITOR LOGIC
# ==========================================

def estimate_date(site_name):
    site_lower = str(site_name).lower()
    known_dates = {
        "linkedin": "2016-05-17", "adobe": "2013-10-04", "canva": "2019-05-24",
        "facebook": "2019-08-30", "twitter": "2022-07-21", "myspace": "2008-07-17",
        "dropbox": "2012-07-01", "zomato": "2017-05-18", "uber": "2016-10-01"
    }
    for key, date in known_dates.items():
        if key in site_lower: return date
    start_date = datetime(2018, 1, 1)
    end_date = datetime(2024, 1, 1)
    random_days = random.randrange((end_date - start_date).days)
    return (start_date + timedelta(days=random_days)).strftime("%Y-%m-%d")

def get_mock_breaches():
    return [
        {"Name": "LinkedIn", "BreachDate": "2016-05-17", "DataClasses": ["Email", "Passwords", "Job titles"], "Description": "164 Million accounts exposed."},
        {"Name": "Adobe", "BreachDate": "2013-10-04", "DataClasses": ["Email", "Hints"], "Description": "153 Million accounts exposed."},
        {"Name": "Zomato", "BreachDate": "2017-05-18", "DataClasses": ["Email", "Passwords"], "Description": "17 Million user records leaked."}
    ]

def get_real_breaches(email):
    url = f"https://leakcheck.io/api/public?check={email}"
    try:
        response = requests.get(url, timeout=5)
        data = response.json()
        if data.get('success') and data.get('sources'):
            real_breaches = []
            for source in data.get('sources'):
                name = source.get('name') if isinstance(source, dict) else source
                real_breaches.append({
                    "Name": name, "BreachDate": estimate_date(name),
                    "DataClasses": ["Email", "Password"], "Description": "Public Database Leak"
                })
            return real_breaches
        return []
    except: return None

def check_password_pwned(password):
    sha1pass = hashlib.sha1(password.encode('utf-8')).hexdigest().upper()
    prefix, suffix = sha1pass[:5], sha1pass[5:]
    try:
        res = requests.get(f"https://api.pwnedpasswords.com/range/{prefix}", timeout=5)
        if res.status_code == 200:
            for line in res.text.splitlines():
                h, count = line.split(':')
                if h == suffix: return int(count)
    except: return -1
    return 0

# --- UPDATED RISK CALCULATION WITH PRIORITIZATION ---
def calculate_risk(breaches):
    score = 0
    priority = "LOW"
    current_year = datetime.now().year
    
    weights = {'Passwords': 30, 'Email': 10, 'Phone': 20, 'Credit Card': 80, 'Social Security': 90}
    
    critical_flag = False
    high_flag = False

    for b in breaches:
        breach_date_str = b.get('BreachDate', '2020-01-01')
        try: breach_year = int(breach_date_str.split('-')[0])
        except: breach_year = 2020
        age = max(1, current_year - breach_year)
        decay_factor = 1.0 / (age ** 0.5)
        
        data_classes = b.get('DataClasses', [])
        breach_score = sum([weights.get(dtype, 15) for dtype in data_classes])
        score += (breach_score * decay_factor)
        
        # Priority Logic: Recent Password/Financial leaks are Critical
        if age <= 3 and ("Passwords" in data_classes or "Credit Card" in data_classes):
            critical_flag = True
        elif "Passwords" in data_classes:
            high_flag = True

    if critical_flag:
        priority = "CRITICAL"
        score = max(score, 75)
    elif high_flag:
        priority = "HIGH"
        score = max(score, 50)
    elif score > 20:
        priority = "MEDIUM"
    
    return min(int(score), 100), priority

# ==========================================
# 4. MODULE 2: HYBRID URL SCANNER LOGIC
# ==========================================

# --- LAYER 0: LOCAL HEURISTICS (NOVELTY) ---
def local_heuristics_engine(url):
    """
    Analyzes URL structure for phishing patterns.
    Returns: Score, Flags, and Priority.
    """
    flags = []
    score = 0
    
    # 1. IP Address Check (Critical)
    ip_pattern = r"^(http|https)://\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"
    if re.match(ip_pattern, url):
        score += 60
        flags.append("Raw IP Address used (Highly Suspicious)")

    # 2. @ Symbol (High Risk)
    if "@" in url:
        score += 40
        flags.append("Obfuscated URL using '@' symbol")

    # 3. Keyword Stuffing (Medium Risk)
    suspicious_keywords = ['login', 'signin', 'verify', 'account', 'update', 'banking', 'secure', 'bonus']
    parsed = urlparse(url)
    url_path = parsed.path + parsed.query
    found_keywords = [word for word in suspicious_keywords if word in url_path.lower()]
    if found_keywords:
        score += 20
        flags.append(f"Urgency keywords found: {', '.join(found_keywords)}")

    # 4. Length Analysis (Low Risk)
    if len(url) > 75:
        score += 10
        flags.append("URL is abnormally long (>75 chars)")

    # Determine Priority
    if score >= 60:
        priority = "CRITICAL" # Block immediately
    elif score >= 20:
        priority = "HIGH"
    else:
        priority = "STANDARD"

    return {"score": score, "flags": flags, "priority": priority}

# --- LAYER 1: GOOGLE SAFE BROWSING ---
def check_google_safe_browsing(url):
    endpoint = f"https://safebrowsing.googleapis.com/v4/threatMatches:find?key={GOOGLE_API_KEY}"
    payload = {
        "client": {"clientId": "cyber-sentinel", "clientVersion": "1.0.0"},
        "threatInfo": {
            "threatTypes": ["MALWARE", "SOCIAL_ENGINEERING", "UNWANTED_SOFTWARE"],
            "platformTypes": ["ANY_PLATFORM"],
            "threatEntryTypes": ["URL"],
            "threatEntries": [{"url": url}]
        }
    }
    try:
        response = requests.post(endpoint, json=payload)
        data = response.json()
        if "matches" in data:
            return {"status": "malicious", "source": "Google Safe Browsing", "detail": data["matches"][0]["threatType"]}
        return {"status": "clean"}
    except Exception as e:
        return {"status": "error", "message": str(e)}

# --- LAYER 2: VIRUSTOTAL ---
def check_virustotal(url):
    headers = {"x-apikey": VIRUSTOTAL_API_KEY, "content-type": "application/x-www-form-urlencoded"}
    try:
        # Step 1: Submit URL
        scan_url = "https://www.virustotal.com/api/v3/urls"
        data = {"url": url}
        resp = requests.post(scan_url, headers=headers, data=data)
        
        if resp.status_code != 200:
            return {"status": "error", "message": f"VT API Error: {resp.status_code}"}
            
        analysis_id = resp.json()["data"]["id"]
        
        # Step 2: Poll Results
        analysis_url = f"https://www.virustotal.com/api/v3/analyses/{analysis_id}"
        with st.spinner("Deep scanning with VirusTotal (approx 15s)..."):
            for _ in range(6): # Poll for ~30 seconds
                time.sleep(5)
                report_resp = requests.get(analysis_url, headers=headers)
                report = report_resp.json()
                status = report["data"]["attributes"]["status"]
                
                if status == "completed":
                    stats = report["data"]["attributes"]["stats"]
                    malicious = stats["malicious"]
                    if malicious > 0:
                        return {"status": "malicious", "source": "VirusTotal", "malicious_votes": malicious, "total_votes": sum(stats.values())}
                    else:
                        return {"status": "clean", "source": "VirusTotal"}
        return {"status": "timeout", "message": "Analysis timed out."}
    except Exception as e:
        return {"status": "error", "message": str(e)}

# ==========================================
# 5. MAIN APPLICATION UI
# ==========================================

st.sidebar.title("üõ°Ô∏è CyberSentinel")
app_mode = st.sidebar.radio("Select Module:", ["Identity Auditor", "PhishGuard URL Scanner"])

st.sidebar.markdown("---")
st.sidebar.caption("üîí Zero-Knowledge Architecture")

# --- APP MODE: IDENTITY AUDITOR ---
if app_mode == "Identity Auditor":
    st.markdown("<h1>üë§ Identity Leak Auditor<br><span style='font-size: 20px;'>Dark Web Credential Monitor</span></h1>", unsafe_allow_html=True)
    st.divider()

    col_a, col_b = st.columns([1, 2])
    with col_a:
        email_input = st.text_input("Target Email Address", "demo@test.com")
        pass_input = st.text_input("Password Check (Optional)", type="password")
        scan_clicked = st.button("üöÄ INITIATE SCAN")

    if scan_clicked:
        st.session_state['run_audit'] = True
    
    if st.session_state.get('run_audit'):
        with st.spinner("üïµÔ∏è Scouring Dark Web Databases..."):
            breaches = get_real_breaches(email_input)
            is_sim = False
            if not breaches and email_input == "demo@test.com":
                breaches = get_mock_breaches()
                is_sim = True
            
            # GET SCORE AND PRIORITY
            if breaches:
                risk_score, priority = calculate_risk(breaches)
            else:
                risk_score, priority = 0, "LOW"

        # --- PRIORITY BASED ALERT SYSTEM ---
        if priority == "CRITICAL":
            st.error(f"üö® CRITICAL PRIORITY (Score: {risk_score}/100)")
            st.markdown("**ACTION REQUIRED:** Passwords or financial data exposed recently. Change passwords immediately.")
        elif priority == "HIGH":
            st.warning(f"‚ö†Ô∏è HIGH PRIORITY (Score: {risk_score}/100)")
            st.markdown("**ACTION REQUIRED:** Passwords found in older leaks. Update credentials.")
        elif priority == "MEDIUM":
            st.info(f"üì¢ MEDIUM PRIORITY (Score: {risk_score}/100)")
            st.markdown("Personal info exposed (Emails/Usernames). Be wary of phishing.")
        else:
            st.success("‚úÖ LOW PRIORITY: System Secure")

        if is_sim: st.caption("‚ÑπÔ∏è Running in Simulation Mode for Demonstration")

        # Tabs
        tab1, tab2, tab3 = st.tabs(["üìä Live Dashboard", "üï∏Ô∏è Attack Map", "üîë Password Lab"])

        with tab1:
            c1, c2, c3 = st.columns(3)
            c1.metric("Total Breaches", len(breaches) if breaches else 0)
            c2.metric("Risk Score", f"{risk_score}/100")
            c3.metric("Priority Level", priority)

            if breaches:
                for b in breaches:
                    with st.expander(f"üî¥ {b['Name']} ({b.get('BreachDate', 'N/A')})"):
                        st.write(f"**Description:** {b.get('Description', 'No details available.')}")
                        st.write(f"**Compromised:** {', '.join(b.get('DataClasses', []))}")
            else: st.info("No breaches to display.")

        with tab2:
            if breaches:
                dates = [datetime.strptime(b.get('BreachDate', '2021-01-01'), "%Y-%m-%d") for b in breaches]
                names = [b['Name'] for b in breaches]
                fig, ax = plt.subplots(figsize=(10, 4))
                fig.patch.set_alpha(0)
                ax.patch.set_alpha(0)
                
                markerline, stemline, baseline = ax.stem(dates, [1]*len(dates))
                plt.setp(markerline, marker='D', markersize=8, markeredgecolor="#0f172a", markerfacecolor="white")
                plt.setp(stemline, color='#0f172a', linestyle='--')
                ax.get_yaxis().set_visible(False)
                ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['left'].set_visible(False)
                ax.spines['bottom'].set_color('#0f172a')
                ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y"))
                ax.tick_params(axis='x', colors='#000')
                for d, name in zip(dates, names):
                    ax.annotate(name, xy=(d, 1.1), xytext=(0, 5), textcoords="offset points", ha='center', fontweight='bold', color="#0f172a")
                st.pyplot(fig)
            else: st.info("No timeline data.")

        with tab3:
            if pass_input:
                leaks = check_password_pwned(pass_input)
                if leaks > 0: st.error(f"Password exposed {leaks:,} times. CHANGE IMMEDIATELY.")
                elif leaks == 0: st.success("Password NOT found in known leaks.")
                else: st.warning("Connection failed.")
            else: st.info("Enter password in top section to test.")

        st.divider()
        if st.button("üìÑ Export Forensic PDF Report"):
            generate_creative_pdf(email_input, risk_score, breaches if breaches else [], priority)
            with open("Risk_Report.pdf", "rb") as f:
                st.download_button("üì• Download PDF", f, "Risk_Report.pdf")

# --- APP MODE: URL SCANNER ---
elif app_mode == "PhishGuard URL Scanner":
    st.markdown("<h1>üåê PhishGuard<br><span style='font-size: 20px;'>Hybrid URL Threat Analyzer</span></h1>", unsafe_allow_html=True)
    st.divider()

    st.markdown("""
    This scanner uses a **Triple-Layer Defense**:
    1.  **üß† Heuristics Engine:** Zero-day analysis of URL structure.
    2.  **üõ°Ô∏è Fast Layer:** Google Safe Browsing Check.
    3.  **üî¨ Deep Layer:** VirusTotal Deep Scan (if needed).
    """)
    
    url_input = st.text_input("Enter Suspicious URL:", placeholder="http://example.com/login")
    if st.button("üîç ANALYZE LINK"):
        if url_input:
            st.write("---")
            
            # --- LAYER 0: LOCAL HEURISTICS (With Prioritization) ---
            st.subheader("1. üß† Local Heuristics Engine")
            
            heuristic = local_heuristics_engine(url_input)
            
            # Display Priority Badge
            if heuristic["priority"] == "CRITICAL":
                st.error(f"PRIORITY: CRITICAL (Score: {heuristic['score']}/100)")
            elif heuristic["priority"] == "HIGH":
                st.warning(f"PRIORITY: HIGH (Score: {heuristic['score']}/100)")
            else:
                st.info(f"PRIORITY: STANDARD (Score: {heuristic['score']}/100)")

            # Show Flags
            for flag in heuristic["flags"]:
                st.write(f"- {flag}")
            
            # CIRCUIT BREAKER (If Critical, Stop here)
            if heuristic["priority"] == "CRITICAL":
                st.error("üö® BLOCKED IMMEDIATELY: High-confidence local threat detected.")
                st.caption("Skipping API checks to save quota and reduce latency.")
                st.stop()
            
            st.write("Proceeding to Global Database Check...")
            time.sleep(1)

            # --- LAYER 1: GOOGLE SAFE BROWSING ---
            st.subheader("2. üõ°Ô∏è Global Database (Google)")
            fast_result = check_google_safe_browsing(url_input)
            
            if fast_result["status"] == "malicious":
                st.error(f"üö® BLOCKED! Detected by {fast_result['source']}")
                st.write(f"**Threat Type:** {fast_result['detail']}")
                st.stop() # Google blocked it, no need for deep scan
            
            elif fast_result["status"] == "error":
                st.warning(f"‚ö†Ô∏è Google API Error: {fast_result.get('message')}")
            else:
                st.success("‚úÖ Google Safe Browsing: Clean")
                
                # --- LAYER 2: VIRUSTOTAL (Deep Scan) ---
                st.subheader("3. üî¨ Deep Layer (VirusTotal)")
                deep_result = check_virustotal(url_input)
                
                if deep_result["status"] == "malicious":
                    st.error(f"üö® BLOCKED! Detected by {deep_result['source']}")
                    st.metric("Malicious Votes", f"{deep_result['malicious_votes']}/{deep_result['total_votes']}")
                elif deep_result["status"] == "clean":
                    st.success("‚úÖ VirusTotal: Clean (0 detections)")
                    st.balloons()
                    st.info("This URL is likely safe.")
                else:
                    st.error(f"Error in deep scan: {deep_result.get('message')}")
        else:
            st.warning("Please enter a URL.")
